#!/bin/bash
# gitlfsdiff: Compare two revisions (HEAD and HEAD~1) of a Git LFSâ€“tracked file.
# Usage: gitlfsdiff <file-path>

set -e

if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <file-path>"
    exit 1
fi

# Determine the repository root
REPO_ROOT=$(git rev-parse --show-toplevel)

# Convert the provided file path to an absolute path and then to a repo-relative path
FILE_ABS=$(realpath "$1")
FILE_REL=$(realpath --relative-to="$REPO_ROOT" "$FILE_ABS")

# Verify that the file exists in HEAD
if ! git ls-tree -r HEAD -- "$FILE_REL" > /dev/null 2>&1; then
    echo "Error: File '$FILE_REL' not found in HEAD."
    exit 1
fi

# Verify that the file is tracked by Git LFS
if ! git lfs ls-files | grep -q "$FILE_REL"; then
    echo "Error: '$FILE_REL' is not tracked by Git LFS."
    exit 1
fi

NEW_COMMIT="HEAD"
OLD_COMMIT="HEAD~1"

OLD_TMP=$(mktemp)
NEW_TMP=$(mktemp)

# Ensure temporary files are removed on exit
cleanup() {
    rm -f "$OLD_TMP" "$NEW_TMP"
}
trap cleanup EXIT

# Retrieve file content from the two revisions using git lfs smudge to restore actual content.
if ! git show "$OLD_COMMIT:$FILE_REL" | git lfs smudge > "$OLD_TMP" 2>/dev/null; then
    echo "Error: Unable to retrieve '$FILE_REL' from $OLD_COMMIT. It may not exist in that commit."
    exit 1
fi

if ! git show "$NEW_COMMIT:$FILE_REL" | git lfs smudge > "$NEW_TMP" 2>/dev/null; then
    echo "Error: Unable to retrieve '$FILE_REL' from $NEW_COMMIT."
    exit 1
fi

# Determine if the file is text or binary and display an appropriate diff.
if file "$OLD_TMP" | grep -qi "text"; then
    echo "Text file detected. Showing unified diff:"
    diff -u "$OLD_TMP" "$NEW_TMP"
else
    echo "Binary file detected. Showing hex diff:"
    diff <(xxd "$OLD_TMP") <(xxd "$NEW_TMP")
fi
